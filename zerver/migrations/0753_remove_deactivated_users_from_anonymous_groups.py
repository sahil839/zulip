# Generated by Django 5.2.6 on 2025-09-22 09:45

from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Q, Value
from django.utils.timezone import now as timezone_now


def remove_deactivated_users_from_anonymous_groups(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    RealmAuditLog = apps.get_model("zerver", "RealmAuditLog")
    NamedUserGroup = apps.get_model("zerver", "NamedUserGroup")
    UserGroupMembership = apps.get_model("zerver", "UserGroupMembership")
    UserGroup = apps.get_model("zerver", "UserGroup")
    Stream = apps.get_model("zerver", "Stream")
    GroupGroupMembership = apps.get_model("zerver", "GroupGroupMembership")

    REALM_PROPERTY_CHANGED = 207
    CHANNEL_GROUP_BASED_SETTING_CHANGED = 608
    USER_GROUP_GROUP_BASED_SETTING_CHANGED = 722

    OLD_VALUE = "1"
    NEW_VALUE = "2"

    REALM_GROUP_PERMISSION_SETTINGS = [
        "create_multiuse_invite_group",
        "can_add_subscribers_group",
        "can_add_custom_emoji_group",
        "can_create_bots_group",
        "can_create_groups",
        "can_create_public_channel_group",
        "can_create_private_channel_group",
        "can_create_write_only_bots_group",
        "can_delete_any_message_group",
        "can_delete_own_message_group",
        "can_invite_users_group",
        "can_manage_all_groups",
        "can_manage_billing_group",
        "can_mention_many_users_group",
        "can_move_messages_between_channels_group",
        "can_move_messages_between_topics_group",
        "can_resolve_topics_group",
        "can_set_delete_message_policy_group",
        "can_set_topics_policy_group",
        "can_summarize_topics_group",
        "direct_message_initiator_group",
        "direct_message_permission_group",
    ]

    STREAM_GROUP_PERMISSION_SETTINGS = [
        "can_add_subscribers_group",
        "can_administer_channel_group",
        "can_delete_any_message_group",
        "can_delete_own_message_group",
        "can_move_messages_out_of_channel_group",
        "can_move_messages_within_channel_group",
        "can_remove_subscribers_group",
        "can_send_message_group",
        "can_subscribe_group",
        "can_resolve_topics_group",
    ]

    USER_GROUP_GROUP_PERMISSION_SETTINGS = [
        "can_add_members_group",
        "can_join_group",
        "can_leave_group",
        "can_manage_group",
        "can_mention_group",
        "can_remove_members_group",
    ]

    def get_members_and_subgroups_of_groups(
        group_ids: set[int],
    ) -> dict[int, dict[str, list[int]]]:
        user_members = (
            UserGroupMembership.objects.filter(user_group_id__in=group_ids)
            .annotate(
                member_type=Value("user"),
            )
            .values_list("member_type", "user_group_id", "user_profile_id")
        )

        group_subgroups = (
            GroupGroupMembership.objects.filter(supergroup_id__in=group_ids)
            .annotate(
                member_type=Value("group"),
            )
            .values_list("member_type", "supergroup_id", "subgroup_id")
        )

        results_dict: dict[int, dict[str, list[int]]] = dict()
        for group_id in group_ids:
            results_dict[group_id] = dict(direct_members=[], direct_subgroups=[])

        all_members = user_members.union(group_subgroups)
        for member_type, group_id, member_id in all_members:
            members_dict = results_dict[group_id]
            if member_type == "user":
                members_dict["direct_members"].append(member_id)
            else:
                members_dict["direct_subgroups"].append(member_id)

        return results_dict

    def get_new_setting_value(
        old_value: dict[str, list[int]],
        deactivated_user_ids: set[int],
        setting_name: str,
        nobody_group_id: int,
        owners_group_id: int,
    ) -> int | dict[str, list[int]]:
        new_members_list = set(old_value["direct_members"]) - deactivated_user_ids
        if len(new_members_list) == 0 and len(old_value["direct_subgroups"]) == 0:
            if setting_name in ["can_manage_all_groups", "can_manage_billing_group"]:
                # These two settings cannot be set to nobody group, so we set them to owners group.
                return owners_group_id

            return nobody_group_id

        if len(new_members_list) == 0 and len(old_value["direct_subgroups"]) == 1:
            return old_value["direct_subgroups"][0]

        return dict(
            direct_members=list(new_members_list), direct_subgroups=old_value["direct_subgroups"]
        )

    for realm in Realm.objects.all():
        audit_log_objects_to_create = []
        deactivated_user_ids: set[int] = set()
        anonymous_group_ids: set[int] = set()

        nobody_group = NamedUserGroup.objects.get(
            name="role:nobody", realm_for_sharding=realm, is_system_group=True
        )
        owners_group = NamedUserGroup.objects.get(
            name="role:owners", realm_for_sharding=realm, is_system_group=True
        )

        anonymous_group_memberships_with_deactivated_user = UserGroupMembership.objects.filter(
            user_group__realm=realm,
            user_group__named_user_group=None,
            user_profile__is_active=False,
        ).values_list("user_group_id", "user_profile_id")

        for group_id, user_id in anonymous_group_memberships_with_deactivated_user:
            deactivated_user_ids.add(user_id)
            anonymous_group_ids.add(group_id)

        membership_dict = get_members_and_subgroups_of_groups(anonymous_group_ids)

        realm_settings_to_update = []
        anonymous_group_ids_to_delete = []
        for setting_name in REALM_GROUP_PERMISSION_SETTINGS:
            setting_group_id = getattr(realm, setting_name + "_id")
            if setting_group_id in anonymous_group_ids:
                new_setting_value = get_new_setting_value(
                    membership_dict[setting_group_id],
                    deactivated_user_ids,
                    setting_name,
                    nobody_group.id,
                    owners_group.id,
                )

                if isinstance(new_setting_value, int):
                    setattr(realm, setting_name + "_id", new_setting_value)
                    realm_settings_to_update.append(setting_name)
                    anonymous_group_ids_to_delete.append(setting_group_id)

                audit_log_objects_to_create.append(
                    RealmAuditLog(
                        realm=realm,
                        event_type=REALM_PROPERTY_CHANGED,
                        event_time=timezone_now(),
                        acting_user=None,
                        extra_data={
                            OLD_VALUE: membership_dict[setting_group_id],
                            NEW_VALUE: new_setting_value,
                            "property": setting_name,
                        },
                        backfilled=True,
                    )
                )

        stream_setting_query = Q()
        for setting_name in STREAM_GROUP_PERMISSION_SETTINGS:
            stream_setting_query |= Q(**{f"{setting_name}__in": anonymous_group_ids})

        stream_settings_to_update = []
        streams_to_update = []
        for stream in Stream.objects.filter(realm=realm).filter(stream_setting_query):
            for setting_name in STREAM_GROUP_PERMISSION_SETTINGS:
                setting_group_id = getattr(stream, setting_name + "_id")
                if setting_group_id in anonymous_group_ids:
                    new_setting_value = get_new_setting_value(
                        membership_dict[setting_group_id],
                        deactivated_user_ids,
                        setting_name,
                        nobody_group.id,
                        owners_group.id,
                    )

                    if isinstance(new_setting_value, int):
                        setattr(stream, setting_name + "_id", new_setting_value)
                        streams_to_update.append(stream)
                        stream_settings_to_update.append(setting_name)
                        anonymous_group_ids_to_delete.append(setting_group_id)

                    audit_log_objects_to_create.append(
                        RealmAuditLog(
                            realm=realm,
                            acting_user=None,
                            modified_stream=stream,
                            event_type=CHANNEL_GROUP_BASED_SETTING_CHANGED,
                            event_time=timezone_now(),
                            extra_data={
                                OLD_VALUE: membership_dict[setting_group_id],
                                NEW_VALUE: new_setting_value,
                                "property": setting_name,
                            },
                            backfilled=True,
                        )
                    )

        group_setting_query = Q()
        for setting_name in USER_GROUP_GROUP_PERMISSION_SETTINGS:
            group_setting_query |= Q(**{f"{setting_name}__in": anonymous_group_ids})

        group_settings_to_update = []
        groups_to_update = []
        for group in NamedUserGroup.objects.filter(realm_for_sharding=realm).filter(
            group_setting_query
        ):
            for setting_name in USER_GROUP_GROUP_PERMISSION_SETTINGS:
                setting_group_id = getattr(group, setting_name + "_id")
                if setting_group_id in anonymous_group_ids:
                    new_setting_value = get_new_setting_value(
                        membership_dict[setting_group_id],
                        deactivated_user_ids,
                        setting_name,
                        nobody_group.id,
                        owners_group.id,
                    )

                    if isinstance(new_setting_value, int):
                        setattr(group, setting_name + "_id", new_setting_value)
                        groups_to_update.append(group)
                        group_settings_to_update.append(setting_name)
                        anonymous_group_ids_to_delete.append(setting_group_id)

                    audit_log_objects_to_create.append(
                        RealmAuditLog(
                            realm=realm,
                            acting_user=None,
                            event_type=USER_GROUP_GROUP_BASED_SETTING_CHANGED,
                            event_time=timezone_now(),
                            modified_user_group=group,
                            extra_data={
                                OLD_VALUE: membership_dict[setting_group_id],
                                NEW_VALUE: new_setting_value,
                                "property": setting_name,
                            },
                            backfilled=True,
                        )
                    )

        with transaction.atomic():
            if realm_settings_to_update:
                realm.save(update_fields=realm_settings_to_update)

            if streams_to_update:
                Stream.objects.bulk_update(streams_to_update, fields=stream_settings_to_update)

            if groups_to_update:
                NamedUserGroup.objects.bulk_update(
                    groups_to_update, fields=group_settings_to_update
                )

            UserGroupMembership.objects.filter(
                user_group__realm=realm,
                user_group__named_user_group=None,
                user_profile__is_active=False,
            ).delete()

            if anonymous_group_ids_to_delete:
                UserGroup.objects.filter(id__in=anonymous_group_ids_to_delete).delete()

            RealmAuditLog.objects.bulk_create(audit_log_objects_to_create)


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0752_remove_stream_is_in_zephyr_realm"),
    ]

    operations = [
        migrations.RunPython(
            remove_deactivated_users_from_anonymous_groups,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        )
    ]
